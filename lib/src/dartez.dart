library dartez;

import 'dart:convert';
import 'dart:math';
import 'dart:typed_data';
import 'dart:core';
import 'package:convert/convert.dart';
import 'package:dartez/utils/wallet_utils.dart';
import 'package:ed25519_hd_key/ed25519_hd_key.dart';
import 'package:bip39/bip39.dart' as bip39;
// ignore: implementation_imports
import 'package:bip32/src/bip32_base.dart' as bip32;
import 'package:dartez/chain/tezos/tezos_language_util.dart';
import 'package:dartez/chain/tezos/tezos_message_utils.dart';
import 'package:dartez/chain/tezos/tezos_node_reader.dart';
import 'package:dartez/chain/tezos/tezos_node_writer.dart';
import 'package:dartez/helper/constants.dart';
import 'package:dartez/helper/http_helper.dart';
import 'package:dartez/helper/operation_helper.dart';
import 'package:dartez/reporting/tezos/tezos_conseil_client.dart';
import 'package:dartez/src/soft-signer/soft_signer.dart';
import 'package:dartez/dartez.dart';
import 'package:dartez/utils/sodium/sodium_utils.dart';
import 'package:dartez/helper/generateKeys.dart';

import '../utils/sodium/platform_impl/sodium_utils_base.dart';

class Dartez {
  static SodiumUtils sodiumUtils = SodiumUtils();

  // init dartez
  Future<void> init() async {
    await sodiumUtils.init();
  }

  /// This function generates a mnemonic phrase of given strength using the BIP39 algorithm.
  static String generateMnemonic({int strength = 256}) {
    // Generate a mnemonic phrase with the given strength and random bytes
    return bip39.generateMnemonic(
        strength: strength,
        randomBytes: (size) {
          // Create a secure random number generator
          final rng = Random.secure();
          // Create a Uint8List to store the random bytes
          final bytes = Uint8List(size);
          // Iterate through the list and assign each element a random value between 0 and 255
          for (var i = 0; i < size; i++) {
            bytes[i] = rng.nextInt(256);
          }
          // Return the generated bytes
          return bytes;
        });
  }

  static KeyStoreModel getKeysFromMnemonic({
    required String mnemonic,
    String passphrase = "",
    SignerCurve signerCurve = SignerCurve.ED25519,
  }) {
    if (signerCurve == SignerCurve.SECP256R1) {
      throw new Exception("SECP256R1 is not supported");
    }
    Uint8List seed = bip39.mnemonicToSeed(mnemonic, passphrase: passphrase);
    Uint8List seedLength32 = seed.sublist(0, 32);
    return WalletUtils().getKeysFromMnemonic(seedLength32, signerCurve);
  }

  static Future<KeyStoreModel> restoreIdentityFromDerivationPath(
      String derivationPath, String mnemonic,
      {String? pkh,
      bool validate = true,
      String passphrase = "",
      SignerCurve signerCurve = SignerCurve.ED25519}) async {
    // if the signer curve is secp256r1 then throw an error as it is not supported
    if (signerCurve == SignerCurve.SECP256R1) {
      throw new Exception("SECP256R1 is not supported");
    }
    if (validate) {
      if (![12, 15, 18, 21, 24].contains(mnemonic.split(' ').length)) {
        throw new Exception("Invalid mnemonic length.");
      }
      if (!bip39.validateMnemonic(mnemonic)) {
        throw new Exception("The given mnemonic could not be validated.");
      }
    }

    Uint8List seed = bip39.mnemonicToSeed(mnemonic);

    if (derivationPath.length > 0) {
      if (signerCurve == SignerCurve.ED25519) {
        KeyData keysource =
            await ED25519_HD_KEY.derivePath(derivationPath, seed);
        var combinedKey =
            Uint8List.fromList(keysource.key + keysource.chainCode);
        return WalletUtils().getKeysFromPrivateKey(
            GenerateKeys.readKeysWithHint(
                combinedKey, GenerateKeys.keyPrefixes[PrefixEnum.edsk]!),
            signerCurve);
      } else {
        // Generate a BIP32 hierarchical deterministic key from the seed
        final masterKey = bip32.BIP32.fromSeed(seed);
        final key = masterKey.derivePath(derivationPath);

        return WalletUtils().getKeysFromPrivateKey(
            GenerateKeys.readKeysWithHint(key.privateKey!.sublist(0, 32),
                GenerateKeys.keyPrefixes[PrefixEnum.spsk]!),
            signerCurve);
      }
    } else {
      return await _unlockKeys(mnemonic: mnemonic, password: passphrase);
    }
  }

  static KeyStoreModel getKeysFromSecretKey(String skKey) {
    if (skKey.startsWith("edsk")) {
      return WalletUtils().getKeysFromPrivateKey(skKey, SignerCurve.ED25519);
    } else if (skKey.startsWith("spsk")) {
      return WalletUtils().getKeysFromPrivateKey(skKey, SignerCurve.SECP256K1);
    } else {
      throw new Exception("Invalid secret key");
    }
  }

  static Future<KeyStoreModel> unlockFundraiserIdentity({
    required String mnemonic,
    String passphrase = "",
  }) async {
    return await _unlockKeys(
      mnemonic: mnemonic,
      password: passphrase,
    );
  }

  static String signPayload({
    required SoftSigner signer,
    required String payload,
  }) {
    var opSignature =
        signer.signOperation(Uint8List.fromList(hex.decode(payload)));
    var base58signature = TezosMessageUtils.readSignatureWithHint(
        opSignature, signer.getSignerCurve());
    return base58signature;
  }

  /// returns a [base58signature, signedOpGroup]
  static List<String> signOperationGroup({
    required String privateKey,
    required String forgedOperation,
  }) {
    SoftSigner signer = Dartez.createSigner(privateKey);
    var opSignature = signer.signOperation(Uint8List.fromList(
        hex.decode(TezosConstants.OperationGroupWatermark + forgedOperation)));
    var signedOpGroup =
        Uint8List.fromList(hex.decode(forgedOperation) + opSignature.toList());
    var base58signature = TezosMessageUtils.readSignatureWithHint(
        opSignature, signer.getSignerCurve());

    return [base58signature, hex.encode(signedOpGroup)];
  }

  static Future<KeyStoreModel> _unlockKeys({
    required String mnemonic,
    String password = "",
  }) async {
    Uint8List seed = bip39.mnemonicToSeed(mnemonic, passphrase: password);
    KeyPair keyPair = sodiumUtils.cryptoSignSeedKeypair(seed);
    String skKey = GenerateKeys.readKeysWithHint(
        keyPair.sk, GenerateKeys.keyPrefixes[PrefixEnum.edsk]!);
    String pkKey = GenerateKeys.readKeysWithHint(
        keyPair.pk, GenerateKeys.keyPrefixes[PrefixEnum.edpk]!);
    String pkKeyHash = GenerateKeys.computeKeyHash(
        keyPair.pk, GenerateKeys.keyPrefixes[PrefixEnum.tz1]!);
    return KeyStoreModel(
        publicKeyHash: pkKeyHash, publicKey: pkKey, secretKey: skKey);
  }

  static Future<String> getBalance(String publicKeyHash, String rpc) async {
    var response = await HttpHelper.performGetRequest(rpc,
        'chains/main/blocks/head/context/contracts/$publicKeyHash/balance');
    return response.toString();
  }

  static Uint8List writeKeyWithHint(key, hint) {
    assert(key != null);
    assert(hint != null);
    return GenerateKeys.writeKeyWithHint(key, hint);
  }

  static String writeAddress(address) {
    //writes tz1 address in base58. Used in micheline while sending contract
    assert(address != null);
    return TezosMessageUtils.writeAddress(address);
  }

  static String normalizePrimitiveRecordOrder(String data) {
    return jsonEncode(
        TezosLanguageUtil.normalizePrimitiveRecordOrder(jsonDecode(data)));
  }

  static SoftSigner createSigner(String privateKey, {int validity = 60}) {
    SignerCurve signerCurve;
    Uint8List secretKey;

    if (privateKey.startsWith("edsk")) {
      signerCurve = SignerCurve.ED25519;
      secretKey = GenerateKeys.writeKeyWithHint(privateKey, "edsk");
    } else if (privateKey.startsWith("spsk")) {
      signerCurve = SignerCurve.SECP256K1;
      secretKey = GenerateKeys.writeKeyWithHint(privateKey, "spsk");
    } else {
      throw Exception("Invalid secret key");
    }

    return SoftSigner.createSigner(secretKey, validity,
        signerCurve: signerCurve);
  }

  /// send a transaction operation
  /// fee, gasLimit and storageLimit are estimated by the fee estimation service
  static sendTransactionOperation(String server, SoftSigner signer,
      KeyStoreModel keyStore, String to, int amount,
      {int offset = 54, bool isKeyRevealed = false}) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);

    return await TezosNodeWriter.sendTransactionOperation(
      server,
      signer,
      keyStore,
      to,
      amount,
      isKeyRevealed: isKeyRevealed,
    );
  }

  /// send a delegation operation
  /// fee, gasLimit and storageLimit are estimated by the fee estimation service
  static sendDelegationOperation(
      String server, SoftSigner signer, KeyStoreModel keyStore, String delegate,
      {offset = 54}) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);
    assert(offset != null);
    return await TezosNodeWriter.sendDelegationOperation(
        server, signer, keyStore, delegate, offset);
  }

  /// send a contract origination operation
  /// fee, gasLimit and storageLimit are estimated by the fee estimation service
  static sendContractOriginationOperation(
    String server,
    SoftSigner signer,
    KeyStoreModel keyStore,
    int amount,
    String delegate,
    String code,
    String storage, {
    TezosParameterFormat codeFormat = TezosParameterFormat.Micheline,
    int offset = 54,
  }) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);
    return await TezosNodeWriter.sendContractOriginationOperation(
      server,
      signer,
      keyStore,
      amount,
      delegate,
      code,
      storage,
      codeFormat,
      offset,
    );
  }

  static awaitOperationConfirmation(serverInfo, network, hash, duration,
      {blocktime}) async {
    assert(serverInfo != null);
    assert(network != null);
    assert(hash != null);
    assert(duration != null);
    return await TezosConseilClient.awaitOperationConfirmation(
        serverInfo, network, hash, duration,
        blocktime: blocktime);
  }

  /// send a contract invocation operation
  /// fee, gasLimit and storageLimit are estimated by the fee estimation service
  static sendContractInvocationOperation(
    String server,
    SoftSigner signer,
    KeyStoreModel keyStore,
    List<String> contract,
    List<int> amount,
    List<String> entrypoint,
    List<String> parameters, {
    var codeFormat = TezosParameterFormat.Micheline,
    offset = 54,
  }) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);
    return await TezosNodeWriter.sendContractInvocationOperation(
        server, signer, keyStore, contract, amount, entrypoint, parameters,
        parameterFormat: codeFormat ?? TezosParameterFormat.Michelson,
        offset: offset ?? 54);
  }

  static sendIdentityActivationOperation(String server, SoftSigner signer,
      KeyStoreModel keyStore, String activationCode) async {
    return await TezosNodeWriter.sendIdentityActivationOperation(
        server, signer, keyStore, activationCode);
  }

  /// send key reveal operation
  /// fee, gasLimit and storageLimit are estimated by the fee estimation service
  static sendKeyRevealOperation(String server, signer, KeyStoreModel keyStore,
      {offset = TezosConstants.HeadBranchOffset}) async {
    assert(signer != null);
    assert(offset != null);
    return await TezosNodeWriter.sendKeyRevealOperation(
        server, signer, keyStore, offset);
  }

  static getContractStorage(String server, String accountHash) async {
    return await TezosNodeReader.getContractStorage(server, accountHash);
  }

  static encodeBigMapKey(Uint8List key) {
    return TezosMessageUtils.encodeBigMapKey(key);
  }

  static Uint8List writePackedData(String value, String type,
      {format = TezosParameterFormat.Micheline}) {
    assert(format != null);
    return Uint8List.fromList(
        hex.decode(TezosMessageUtils.writePackedData(value, type, format)));
  }

  static getValueForBigMapKey(String server, String index, String key,
      {block = 'head', chainid = 'main'}) async {
    return await TezosNodeReader.getValueForBigMapKey(server, index, key,
        block: 'head', chainid: 'main');
  }

  static injectOperation(String server, Map<String, dynamic> opPair) async {
    return await TezosNodeWriter.injectOperation(server, opPair);
  }

  static Future<Map<String, dynamic>> preapplyContractInvocationOperation(
    String server,
    SoftSigner signer,
    KeyStoreModel keyStore,
    List<String> contract,
    List<int> amount,
    List<String> entrypoint,
    List<String> parameters, {
    var codeFormat = TezosParameterFormat.Micheline,
    offset = 54,
  }) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);
    return await TezosNodeWriter.sendContractInvocationOperation(
        server, signer, keyStore, contract, amount, entrypoint, parameters,
        parameterFormat: codeFormat ?? TezosParameterFormat.Michelson,
        offset: offset ?? 54,
        preapply: true,
        gasEstimation: true);
  }

  static Future<String?> getOperationStatus(
      String server, String opHash) async {
    return await OperationHelper().getOperationStatus(server, opHash);
  }

  static Future<String> getBlock(String server) async {
    return await OperationHelper().getBlock(server);
  }

  static Future<dynamic> sendContractInvocatoinOperation(
    String server,
    SoftSigner signer,
    KeyStoreModel keyStore,
    List<String> contract,
    List<int> amount,
    List<String> entrypoint,
    List<String> parameters, {
    var codeFormat = TezosParameterFormat.Micheline,
    offset = 54,
  }) async {
    assert(keyStore.publicKey != null);
    assert(keyStore.secretKey != null);

    return await TezosNodeWriter.sendContractInvocationOperation(
        server, signer, keyStore, contract, amount, entrypoint, parameters,
        parameterFormat: codeFormat ?? TezosParameterFormat.Michelson,
        offset: offset ?? 54,
        preapply: false);
  }
}
